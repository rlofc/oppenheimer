// OPPENHEIMER - hierarchical lists boards for the atomic age
// ██████████████████████████████████████████████████████████████████
// ██████████████████████████████████████████████████████████████████
// ████████████████████████░░░░░░░░░░░░░░░░░░████████████████████████
// █████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░████████████████████
// ████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░███████████████████
// ████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░██████████████████
// ████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░██████████████████
// ████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░██████████████████
// ███████████████████░░░░░░░░░░░░░░░░░░▒▒▒▒░░░░░░░██████████████████
// ███████████████████░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░██████████████████
// ██████████████████░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░██████████████████
// ███████░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░▓▓▓████████
// ████▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░████
// ████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░█████
// █████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓██████████
// █████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░█████████████████
// █████████████████▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░█████████████████
// ██████████████████░░░░░░░░░░░░░░░▒░░░░░░░░░░░░░░░█████████████████
// ██████████████████░░░░░░░░░░░░░▒▒▒░░░░░░░░░░░░░░░█████████████████
// ███████████████████░░░░░░░░░░░░▒▒▒░░░░░░░░░░░░░░██████████████████
// ████████████████████░░░░░░░░░░░░░▒░░░░░░░░░░░░░███████████████████
// ████████████████████▓░░░░░░░░░░░░▒▒░░░░░░░░░░░████████████████████
// █████████████████████░░░░░░░░░░░░░▒░░░░░░░░░░░████████████████████
// █████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░████████████████████
// █████████████████████▒░░░░░░░░░░░░░░░░░░░░░░░█████████████████████
// ██████████████████████░░░░░░░░░░░░░░░░░░░░░░░█████████████████████
// ███████████████████████░░░░░░░░░░░░▓██░░░░░░█░░███████████████████
// ███████████████████████░░░░░░░░░░░░░░██░░░░░█░░░██████████████████
// █████████████████████░░░░█░░░░░░░░░░░░███░░░█░░░░█████████████████
// ███████████████████▒░░░░░█░░░░░░░░░░░░░███▓██░░░░░░░▒█████████████
// ████████████████░░░░░░░░░███░░░░░░░░░░░░████░░░░░░░░░░░░░░████████
// ████████▓░░░░░░░░░░░░░░▓░████░░░░░░░░░██████░░░░░░░░░░░░░░░░░░░░░▓
// ███░░░░░░░░░░░░░░░░░░░░████████▓░░░████████░░░░░░░░░░░░░░░░░░░░░░░
// ░░░░░░░░░░░░░░░░░░░░░░█████████▓░███████░░░░░░░░░░░░░░░░░░░░░░░░░░
// ░░░░░░░░░░░░░░░░░░░░░░████████░░░░▓██████░░░░░░░░░░░░░░░░░░░░░░░░░
// ░░░░░░░░░░░░░░░░░░░░░░███████░░░░░░████░█░░░░░░░░░░░░░░░░░░░░░░░░░
// ░░░░░░░░░░░░░░░░░░░░░░░██████░░░░░░░█████░░░░░░░░░░░░░░░░░░░░░░░░░
// ░░░░░░░░░░░░░░░░░░░░░░░█████░░░░░░░░████░░░░░░░░░░░░░░░░░░░░░░░░░░
// ░░░░░░░░░░░░░░░░░░░░░░█████░░░░░░░░░░███░░░░░░░░░░░░░░░░░░░░░░░░░░
// ░░░░░░░░░░░░░░░░░░░░░░███▒░░░░░░░░░░░▓█░░░░░░░░░░░░░░░░░░░░░░░░░░░
// ░░░░░░░░░░░░░░░░░░░░░░████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
// ░░░░░░░░░░░░░░░░░░░░░░██▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
// ░░░░░░░░░░░░░░░░░░░░░▓██░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
// ░░░░░░░░░░░░░░░░░░░░░██░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
// ░░░░░░░░░░░░░░░░░░░░░█░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

use crossterm::event::KeyModifiers;
use search::{FilteredBoardView, SearchController};
use std::{collections::VecDeque, path::PathBuf};

mod board;
mod commands;
mod config;
mod help;
mod input;
mod list;
mod markdown;
mod search;

use board::*;
use commands::*;
use help::*;
use input::*;
use list::*;

use ratatui::{
    crossterm::event::{self, Event, KeyCode},
    layout::{Constraint, Layout, Position, Rect},
    style::{Color, Modifier, Style},
    text::{Line, Span},
    widgets::Paragraph,
    DefaultTerminal, Frame,
};

fn main() {
    let terminal = ratatui::init();
    let mut app = App::new();
    if let Err(err) = app.run(terminal) {
        eprintln!("Application error: {:?}", err);
    }
    ratatui::restore();
}

#[derive(Default)]
struct App {
    filename: PathBuf,
    boards: Vec<Board>,
    board_path: VecDeque<BoardReference>,
    undo: VecDeque<BoardCommand>,
    redo: VecDeque<BoardCommand>,
    staged: Option<Box<dyn StagedCommand>>,
    input_mode: InputMode,
    search: SearchController,
    view: FilteredBoardView,
    clipboard: Option<String>,
    config: config::Config,
}

struct BoardReference {
    board: usize,
    source_board: usize,
    source_list: Option<usize>,
    source_item: Option<usize>,
}

struct BoardCommand {
    board_index: usize,
    command: Box<dyn Command>,
}

impl BoardCommand {
    pub fn new(board_index: usize, command: Box<dyn Command>) -> Self {
        Self {
            board_index,
            command,
        }
    }
}

#[derive(Default, PartialEq, Eq)]
pub enum InputMode {
    #[default]
    Normal,
    EditTitle,
    EditItem,
    Search,
    Help,
}

impl App {
    fn new() -> Self {
        let filename: PathBuf = std::env::args()
            .nth(1)
            .expect("Usage: oppenheimer {filename.md}")
            .into();
        let config = App::load_config();
        let mut app = Self {
            boards: vec![Board::default().with_config(config.board_config.clone())],
            board_path: VecDeque::new(),
            filename: filename.clone(),
            config,
            ..Default::default()
        };
        if std::path::Path::new(&filename).exists() {
            app.load_md(&filename, 0);
        }
        app
    }

    fn load_config() -> config::Config {
        confy::load("oppenheimer", Some("config")).unwrap()
    }

    fn run(&mut self, mut terminal: DefaultTerminal) -> std::io::Result<()> {
        loop {
            terminal.draw(|frame| self.draw(frame))?;
            if let Event::Key(key) = event::read()? {
                match self.input_mode {
                    InputMode::Normal => {
                        if key.modifiers == KeyModifiers::SHIFT {
                            match key.code {
                                KeyCode::Left | KeyCode::Char('H') => {
                                    self.shuffle_list_forward();
                                }
                                KeyCode::Right | KeyCode::Char('L') => {
                                    self.shuffle_list_back();
                                }
                                _ => {}
                            }
                        } else if key.modifiers == KeyModifiers::CONTROL {
                            match key.code {
                                KeyCode::Left | KeyCode::Char('h') => {
                                    self.move_to_prev_list();
                                }
                                KeyCode::Right | KeyCode::Char('l') => {
                                    self.move_to_next_list();
                                }
                                KeyCode::Down | KeyCode::Char('j') => {
                                    self.deprioritize_selected_item();
                                }
                                KeyCode::Up | KeyCode::Char('k') => {
                                    self.prioritize_selected_item();
                                }
                                KeyCode::Char('o') => {
                                    self.insert_list_to_board();
                                }
                                KeyCode::Char('d') => self.delete_selected_list(),
                                _ => {}
                            }
                        } else {
                            match key.code {
                                KeyCode::Char('q') => break Ok(()),
                                KeyCode::Char('/') => self.search(),
                                KeyCode::Char('?') => self.help(),
                                KeyCode::Char('u') => self.undo(),
                                KeyCode::Char('r') => self.redo(),
                                KeyCode::Char('o') => self.insert_item_to_current_list(),
                                KeyCode::Char('d') => self.delete_selected_item(),
                                KeyCode::Char('x') => self.cut_selected_item(),
                                KeyCode::Char('y') => self.yank_selected_item(),
                                KeyCode::Char('p') => self.paste_item(),
                                KeyCode::Enter => self.edit_current_item(),
                                KeyCode::Esc => self.pop_board(),
                                KeyCode::Char(' ') => self.toggle_selected_item(),
                                KeyCode::Tab => self.push_board(),
                                KeyCode::Down | KeyCode::Char('j') => {
                                    self.active_board_mut().move_down()
                                }
                                KeyCode::Up | KeyCode::Char('k') => {
                                    self.active_board_mut().move_up()
                                }
                                KeyCode::Right | KeyCode::Char('l') => {
                                    self.active_board_mut().move_right()
                                }
                                KeyCode::Left | KeyCode::Char('h') => {
                                    self.active_board_mut().move_left()
                                }
                                _ => {}
                            }
                        }
                    }
                    InputMode::EditTitle => {
                        match self.active_board_mut().process_input_for_title(key) {
                            InputAction::Done => {
                                self.commit_board_command();
                                self.input_mode = InputMode::Normal;
                            }
                            InputAction::NewItem => {
                                self.commit_board_command();
                                self.insert_item_to_current_list();
                            }
                            _ => (),
                        }
                    }
                    InputMode::EditItem => {
                        match self.active_board_mut().process_input_for_item(key) {
                            InputAction::Done => {
                                self.commit_board_command();
                                self.input_mode = InputMode::Normal;
                            }
                            InputAction::NewItem => {
                                self.commit_board_command();
                                self.insert_item_to_current_list();
                            }
                            _ => (),
                        }
                    }
                    InputMode::Search => {
                        let view = self.view.clone();
                        match key.code {
                            KeyCode::Down | KeyCode::Up | KeyCode::Left | KeyCode::Right => {
                                view.navigate_actual_board(self.active_board_mut(), &key);
                            }
                            KeyCode::Esc | KeyCode::Enter => {
                                if self.active_board().filter != "" {
                                    view.select_item_from_view(self.active_board_mut());
                                }
                                self.active_board_mut().filter = "".to_string();
                                self.input_mode = InputMode::Normal;
                            }
                            _ => {
                                self.active_board_mut().filter = self.search.input(key);
                                let updated_view = self.search.reflect(self.active_board());
                                updated_view.update_view_selection(self.active_board_mut());
                                self.view = updated_view;
                                ()
                            }
                        }
                    }
                    InputMode::Help => {
                        self.input_mode = InputMode::Normal;
                    }
                }
            }
        }
    }

    fn make_context(&mut self) -> Context {
        // TODO: context should actually become app state
        let d = self.clipboard.clone();
        Context {
            board: self.active_board_mut(),
            clipboard: d,
        }
    }

    fn commit_board_command(&mut self) {
        let mut c = self.staged.take().unwrap();
        if c.finalize(self.active_board_mut()) {
            self.undo
                .push_front(BoardCommand::new(self.active_board_index(), c.to_cmd()));
            self.save_board();
            self.redo.clear();
        } else {
            let mut context = self.make_context();
            c.revert(&mut context);
        }
    }

    fn active_board_index(&self) -> usize {
        if let Some(r) = self.board_path.front() {
            r.board
        } else {
            0
        }
    }

    fn active_board(&self) -> &Board {
        &self.boards[self.active_board_index()]
    }

    fn active_board_mut(&mut self) -> &mut Board {
        let index = self.active_board_index();
        &mut self.boards[index]
    }

    fn prioritize_selected_item(&mut self) {
        if let Some(mut cmd) = self.active_board_mut().prioritize_selected_item() {
            let mut context = self.make_context();
            cmd.apply(&mut context);
            self.undo
                .push_front(BoardCommand::new(self.active_board_index(), cmd));
            self.save_board();
            self.redo.clear();
        }
    }

    fn deprioritize_selected_item(&mut self) {
        if let Some(mut cmd) = self.active_board_mut().deprioritize_selected_item() {
            let mut context = self.make_context();
            cmd.apply(&mut context);
            self.undo
                .push_front(BoardCommand::new(self.active_board_index(), cmd));
            self.save_board();
            self.redo.clear();
        }
    }

    fn move_to_prev_list(&mut self) {
        if self.active_board().current_list.is_some() {
            let index = self.active_board().get_current_selection_index();
            if let Some(mut cmd) = self.active_board_mut().move_to_prev_list(index) {
                let mut context = self.make_context();
                cmd.apply(&mut context);
                self.undo
                    .push_front(BoardCommand::new(self.active_board_index(), cmd));
                self.save_board();
                self.redo.clear();
            }
        }
    }

    fn move_to_next_list(&mut self) {
        if self.active_board().current_list.is_some() {
            let index = self.active_board().get_current_selection_index();
            if let Some(mut cmd) = self.active_board_mut().move_to_next_list(index) {
                let mut context = self.make_context();
                cmd.apply(&mut context);
                self.undo
                    .push_front(BoardCommand::new(self.active_board_index(), cmd));
                self.save_board();
                self.redo.clear();
            }
        }
    }

    fn insert_item_to_current_list(&mut self) {
        if let Some(cmd) = self.active_board_mut().insert_item_to_current_list() {
            self.staged = Some(cmd);
            self.input_mode = InputMode::EditItem
        }
    }

    fn delete_selected_item(&mut self) {
        if let Some(mut cmd) = self.active_board_mut().delete_selected_item() {
            let mut context = self.make_context();
            cmd.apply(&mut context);
            self.undo
                .push_front(BoardCommand::new(self.active_board_index(), cmd));
            self.save_board();
            self.redo.clear();
        }
    }

    fn cut_selected_item(&mut self) {
        if let Some(mut cmd) = self.active_board_mut().cut_selected_item() {
            let mut context = self.make_context();
            cmd.apply(&mut context);
            self.clipboard = context.clipboard;
            self.undo
                .push_front(BoardCommand::new(self.active_board_index(), cmd));
            self.save_board();
            self.redo.clear();
        }
    }

    fn yank_selected_item(&mut self) {
        if let Some(mut cmd) = self.active_board_mut().yank_selected_item() {
            let mut context = self.make_context();
            cmd.apply(&mut context);
            self.clipboard = context.clipboard;
            self.undo
                .push_front(BoardCommand::new(self.active_board_index(), cmd));
            self.save_board();
            self.redo.clear();
        }
    }

    fn paste_item(&mut self) {
        if self.clipboard.is_some()
            && let Some(mut cmd) = self.active_board_mut().paste_item()
        {
            let mut context = self.make_context();
            cmd.apply(&mut context);
            self.undo
                .push_front(BoardCommand::new(self.active_board_index(), cmd));
            self.save_board();
            self.redo.clear();
        }
    }

    fn insert_list_to_board(&mut self) {
        if let Some(cmd) = self.active_board_mut().insert_list_to_board() {
            self.staged = Some(cmd);
            self.input_mode = InputMode::EditTitle;
        }
    }

    fn delete_selected_list(&mut self) {
        if let Some(mut cmd) = self.active_board_mut().delete_selected_list() {
            let mut context = self.make_context();
            cmd.apply(&mut context);
            self.undo
                .push_front(BoardCommand::new(self.active_board_index(), cmd));
            self.save_board();
            self.redo.clear();
        }
    }

    fn toggle_selected_item(&mut self) {
        if let Some(mut cmd) = self.active_board_mut().toggle_selected_item() {
            let mut context = self.make_context();
            cmd.apply(&mut context);
            self.undo
                .push_front(BoardCommand::new(self.active_board_index(), cmd));
            self.save_board();
            self.redo.clear();
        }
    }

    fn shuffle_list_forward(&mut self) {
        if let Some(mut cmd) = self.active_board_mut().shuffle_list_forward() {
            let mut context = self.make_context();
            cmd.apply(&mut context);
            self.undo
                .push_front(BoardCommand::new(self.active_board_index(), cmd));
            self.save_board();
            self.redo.clear();
        }
    }

    fn shuffle_list_back(&mut self) {
        if let Some(mut cmd) = self.active_board_mut().shuffle_list_back() {
            let mut context = self.make_context();
            cmd.apply(&mut context);
            self.undo
                .push_front(BoardCommand::new(self.active_board_index(), cmd));
            self.save_board();
        }
    }

    fn edit_current_item(&mut self) {
        if let Some(cmd) = self.active_board_mut().edit_current_item() {
            self.staged = Some(cmd);
            self.input_mode = InputMode::EditItem
        }
    }

    fn push_board_for_active_item(&mut self, board: usize) {
        self.board_path.push_front(BoardReference {
            board,
            source_board: self.active_board_index(),
            source_list: Some(self.active_board().current_list.unwrap()),
            source_item: Some(
                self.active_board()
                    .current_list()
                    .unwrap()
                    .selected_item_index
                    .unwrap(),
            ),
        });
    }

    fn push_board(&mut self) {
        if let Some(current_list) = self.active_board().current_list() {
            if let Some(current_item) = current_list.current_item() {
                if let Some(board) = current_item.board {
                    self.boards[board].config = self.config.board_config.clone();
                    self.push_board_for_active_item(board);
                } else {
                    self.boards
                        .push(Board::default().with_config(self.config.board_config.clone()));
                    let new_board_index = self.boards.len() - 1;
                    self.active_board_mut()
                        .current_list_mut()
                        .unwrap()
                        .current_item_mut()
                        .unwrap()
                        .board = Some(new_board_index);
                    self.push_board_for_active_item(new_board_index);
                }
            }
        }
    }

    fn pop_board(&mut self) {
        if let Some(r) = self.board_path.pop_front() {
            if self.boards[r.board].lists.is_empty() {
                if let (Some(source_list), Some(source_item)) = (r.source_list, r.source_item) {
                    self.boards[r.source_board].lists[source_list].items[source_item].board = None;
                }
            }
        }
    }

    fn undo(&mut self) {
        if let Some(mut board_command) = self.undo.pop_front() {
            if let Some(list) = self.active_board_mut().current_list_mut() {
                list.clear_selection();
            }
            if board_command.board_index != self.active_board_index() {
                self.board_path.push_front(BoardReference {
                    board: board_command.board_index,
                    source_board: self.active_board_index(),
                    source_list: None,
                    source_item: None,
                });
            }
            let mut context = Context {
                board: &mut self.boards[board_command.board_index],
                clipboard: self.clipboard.clone(),
            };
            board_command.command.revert(&mut context);
            self.clipboard = context.clipboard;
            self.redo.push_front(board_command);
            self.save_board();
        }
    }

    fn redo(&mut self) {
        if let Some(mut board_command) = self.redo.pop_front() {
            if let Some(list) = self.active_board_mut().current_list_mut() {
                list.clear_selection();
            }
            if board_command.board_index != self.active_board_index() {
                self.board_path.push_front(BoardReference {
                    board: board_command.board_index,
                    source_board: self.active_board_index(),
                    source_list: None,
                    source_item: None,
                });
            }
            let mut context = Context {
                board: &mut self.boards[board_command.board_index],
                clipboard: self.clipboard.clone(),
            };
            board_command.command.apply(&mut context);
            self.clipboard = context.clipboard;
            self.undo.push_front(board_command);
            self.save_board();
        }
    }

    fn draw_status_line(&self, frame: &mut Frame, rect: Rect) {
        let list = Paragraph::new("");
        frame.render_widget(list, rect);
    }

    fn draw(&mut self, frame: &mut Frame) {
        let horizontal = Layout::vertical([Constraint::Fill(1), Constraint::Length(1)]);
        let [center, bottom] = horizontal.areas(frame.area());
        let lists_screen_area = self.active_board_mut().draw(frame, center);
        match self.input_mode {
            InputMode::EditTitle => {
                let (x, y) = self.active_board().cursor_position_in_list_title();
                frame.set_cursor_position(Position::new(lists_screen_area.x + x, y))
            }
            InputMode::EditItem => {
                let (x, y) = self.active_board().cursor_position_in_list_item();
                frame.set_cursor_position(Position::new(
                    lists_screen_area.x + x,
                    lists_screen_area.y + y,
                ))
            }
            InputMode::Search => {
                self.search.draw(frame);
                ()
            }
            _ => {}
        }
        self.draw_status_line(frame, bottom);
        if self.input_mode == InputMode::Help {
            self.draw_help_popup(frame);
        }
    }

    fn draw_help_popup(&self, frame: &mut Frame) {
        show_help_popup(frame);
    }

    fn save_board(&self) {
        self.write_md(&self.filename);
    }

    fn search(&mut self) {
        self.search.clear();
        self.input_mode = InputMode::Search;
    }

    fn help(&mut self) {
        self.input_mode = InputMode::Help;
    }
}
